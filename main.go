/*
 * ODS
 *
 * This is a simple REST API to access Block Chain on Ethereum and handling Smart Contracts and Payment Channel as well.
 *
 * API version: 1.0.0
 * Contact: u.kuehn@tu-berlin.de
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package main

import (
	"fmt"
	"time"

	"github.com/davecgh/go-spew/spew"

	"github.com/rs/zerolog"
	"github.com/rs/zerolog/diode"
	"github.com/rs/zerolog/log"

	"net"
	"net/http"
	"os"

	// WARNING!
	// Change this to a fully-qualified import path
	// once you place this file into your project.
	// For example,
	//
	//    sw "github.com/myname/myrepo/go"
	//

	"flag"
	pc "restapidemo/files/paymentchannel"
	sw "restapidemo/go"
	"restapidemo/mdbal"

	"github.com/perun-network/perun-eth-demo/cmd"
)

var BlockChainUrl, DatabaseIpAddress, PublicIpAddress *string

func main() {
	debug := false

	wr := diode.NewWriter(os.Stdout, 1000, 10*time.Millisecond, func(missed int) {
		fmt.Printf("Logger Dropped %d messages.", missed)
	})

	log.Logger = zerolog.New(wr).With().Caller().Logger()
	zerolog.SetGlobalLevel(zerolog.InfoLevel)
	if debug {
		zerolog.SetGlobalLevel(zerolog.DebugLevel)
	}
	log.Info().Str("cmd-line args", spew.Sdump(os.Args))
	arg := os.Args[1]

	serveMode := flag.Bool("server", false, "set to start the server mode")
	BlockChainUrl = flag.String("bc", "", "set a different clock chain root node")
	DatabaseIpAddress = flag.String("db", "", "set a different clock chain root node")
	PublicIpAddress = flag.String("pub", "", "set a different clock chain root node")
	flag.Parse()

	if BlockChainUrl != nil && *BlockChainUrl != "" {
		pc.OptionalConfig.BlockChainUrl = *BlockChainUrl
		log.Info().Msgf("Use block chain boot node %s", *BlockChainUrl)
	} else {
		log.Info().Msg("No alternative block chain boot node have been set, using local config")
	}

	if DatabaseIpAddress != nil && *DatabaseIpAddress != "" {
		pc.OptionalConfig.DatabaseIpAddress = *DatabaseIpAddress
		mdbal.MariaDbConn.Addr = pc.OptionalConfig.DatabaseIpAddress
		log.Info().Msgf("Use database node %s", *DatabaseIpAddress)
	} else {
		log.Info().Msg("No database have been set, using local sessions only")
	}

	if PublicIpAddress != nil && *PublicIpAddress != "" {
		pc.OptionalConfig.PublicIpAddress = *PublicIpAddress
		log.Info().Msgf("Use public ip address for current api node %s", *PublicIpAddress)
	} else {
		conn, err := net.Dial("udp", "8.8.8.8:80")
		if err != nil {
			log.Info().Msgf("Cannot resolve public IP Address %s", err)
			log.Info().Msgf("No public ip address have been set, try using local eth0 address")
			// fall back, if google call don work
			// does not return public ip addr inside docker environments
			pc.OptionalConfig.PublicIpAddress = GetLocalIP()
		} else {
			log.Info().Msg(fmt.Sprintln("No public ip address have been set, try using local eth0 address"))
			localAddr := conn.LocalAddr().(*net.UDPAddr)
			pc.OptionalConfig.PublicIpAddress = localAddr.IP.String()
		}
		defer conn.Close()

		log.Info().Msgf("set public IP Address to %s", pc.OptionalConfig.PublicIpAddress)
	}

	if arg == "demo" {
		cmd.Execute()
	} else if *serveMode == true {
		serve()
	} else {
		log.Info().Msgf("no args given ... abort")
		return
	}
}

func serve() {
	log.Info().Msg("Server started")
	router := sw.NewRouter()
	var staticDir = "/api/"
	router.Handle(staticDir, http.StripPrefix(staticDir, http.FileServer(http.Dir("."+staticDir))))
	router.HandleFunc("/api/swagger-ui.css.map", jsUiCssM)
	router.HandleFunc("/api/swagger-ui-standalone-preset.js.map", jsUiStandaloneM)
	router.HandleFunc("/api/swagger-ui-bundle.js.map", jsUiBundleM)
	router.HandleFunc("/api/swagger-ui.css", jsUiCss)
	router.HandleFunc("/api/swagger-ui-standalone-preset.js", jsUiStandalone)
	router.HandleFunc("/api/swagger-ui-bundle.js", jsUiBundle)
	router.HandleFunc("/api/swagger.json", jsonSwagger)
	router.HandleFunc("/api/favicon-16x16.png", favicon16)
	router.HandleFunc("/api/favicon-32x32.png", favicon32)

	done := http.ListenAndServe("0.0.0.0:8080", router)
	log.Fatal().Msg(done.Error())
}

func favicon16(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "image/png")
	http.ServeFile(w, r, "./api/favicon-16x16.png")
}

func favicon32(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "image/png")
	http.ServeFile(w, r, "./api/favicon-32x32.png")
}

func jsonSwagger(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	http.ServeFile(w, r, "./api/swagger.json")
}

func jsUiCss(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "text/css")
	http.ServeFile(w, r, "./api/swagger-ui.css")
}

func jsUiStandalone(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "text/javascript;charset=utf-8")
	http.ServeFile(w, r, "./api/swagger-ui-standalone-preset.js")
}

func jsUiBundle(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "text/javascript;charset=utf-8")
	http.ServeFile(w, r, "./api/swagger-ui-bundle.js")
}

func jsUiCssM(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "text/css")
	http.ServeFile(w, r, "./api/swagger-ui.css.map")
}

func jsUiStandaloneM(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "text/javascript;charset=utf-8")
	http.ServeFile(w, r, "./api/swagger-ui-standalone-preset.js.map")
}

func jsUiBundleM(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "text/javascript;charset=utf-8")
	http.ServeFile(w, r, "./api/swagger-ui-bundle.js.map")
}

// GetLocalIP returns the non loopback local IP of the host
func GetLocalIP() string {
	addrs, err := net.InterfaceAddrs()
	if err != nil {
		return ""
	}
	for _, address := range addrs {
		// check the address type and if it is not a loopback the display it
		if ipnet, ok := address.(*net.IPNet); ok && !ipnet.IP.IsLoopback() {
			if ipnet.IP.To4() != nil {
				return ipnet.IP.String()
			}
		}
	}
	return ""
}
