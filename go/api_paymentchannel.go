/*
 * ODS
 *
 * This is a simple REST API to access Block Chain on Ethereum and handling Smart Contracts and Payment Channel as well.
 *
 * API version: 1.0.0
 * Contact: u.kuehn@tu-berlin.de
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package swagger

import (
	"encoding/json"

	"github.com/rs/zerolog/log"

	"net/http"
	"fmt"

	pch "restapidemo/files/paymentchannel"
	"restapidemo/mdbal"
	"restapidemo/model"
	"restapidemo/hypercore"
	"restapidemo/redis"
	
)

var sessions map[string]*pch.Session = make(map[string]*pch.Session)

func testRedisUserSession(){

	

	//Test basic add,find and delete functions 

	//model.UserSession instance for testing purposes
	aliceSession := model.UserSession{
		Alias:   "alice",
		Ip_Addr: "127.0.0.1",
		Port:    5751,
	}
	
	rdb := redis.CreateNewDatabase("localhost:6379")


	err1 := redis.AddOrUpdateUserSession(rdb,aliceSession)
	if err1 != nil {
		log.Info().Msgf("cannot add or update user session, %s", err1)
	}

	sess,err2 := redis.FindUserSession(rdb,"alice")
	if err2 != nil  {
		log.Info().Msgf("cannot correctly find alice, %s", err2)
	}
	
	if sess == aliceSession {
        fmt.Println("emp1 annd emp2 are equal")
    } else {
        fmt.Println("emp1 annd emp2 are not equal")
	}

	err3 := redis.DeleteUserSession(rdb,"alice")
	if err3 != nil  {
		log.Info().Msgf("cannot delete alice, %s", err3)
	}

	_,err4 := redis.FindUserSession(rdb,"alice")
	if err4 == nil  {
		log.Info().Msgf("unexpected result, alice not correctly deleted, %s", err4)
	}

	//Test encryption

	secretKey :=redis.CreateSecretKey("6368616e676520746869732070617373776f726420746f206120736563726574")

	bobSession := model.UserSession{
		Alias:   "bob",
		Ip_Addr: "127.0.0.12",
		Port:    5752,
	}

	err5 := redis.AddOrUpdateEncryptedUserSession(rdb,secretKey,bobSession)
	if err5 != nil {
		log.Info().Msgf("cannot add or update encrypted user session, %s", err5)
	}

	sess2,err6 := redis.FindEncryptedUserSession(rdb,secretKey,"bob")
	if err6 != nil  {
		log.Info().Msgf("cannot correctly find encrypted bob session, %s", err6)
	}
	
	if sess2 == bobSession {
        fmt.Println("✅session before encrytion and after decryption are equal, encryption working correctly✅")
    } else {
        fmt.Println("❌ session before encrytion and after decryption are not equal, encryption not working correctly❌")

	}

	err7 := redis.DeleteUserSession(rdb,"bob")
	if err7 != nil  {
		log.Info().Msgf("cannot delete bob, %s", err7)
	}

	if err1 == nil	&& err2 == nil && err3 == nil && err5 == nil && err6 == nil && err7 == nil {
		log.Info().Msgf("✅ All tests passed ✅")
	}else{
		log.Info().Msgf("❌ Testing failed, check logs for errors ❌")
	}
	

}

func testHypercoreUserSession() {
	//Test basic add find functions

	aliceSession := model.UserSession{
		Alias:   "alice",
		Ip_Addr: "127.0.0.1",
		Port:    5751,
	}

	err1 := hypercore.StartUserSession(aliceSession)
	if err1 != nil {
		log.Info().Msgf("cannot start user session, %s", err1)
	}

	sess, err2 := hypercore.FindUserSession("alice")
	if err2 != nil {
		log.Info().Msgf("cannot correctly find alice, %s", err2)
	}

	if sess == aliceSession {
		fmt.Println("emp1 annd emp2 are equal")
	} else {
		fmt.Println("emp1 annd emp2 are not equal")
	}

}



func testUserSession() {
	log.Info().Msgf("Trying connect to database on %s", mdbal.MariaDbConn.Addr)
	mdbal.MariaDbConn.Open()

	data := model.UserSession{Alias: "alice", Ip_Addr: "192.168.1.150", Port: 5750}
	mdbal.MariaDbConn.CreateOrUpdateUserSession(data)

	data.Ip_Addr = "192.168.0.1"
	data.Alias = "bob"
	data.Port += 1
	mdbal.MariaDbConn.CreateOrUpdateUserSession(data)

	data.Alias = "charlie"
	err := mdbal.MariaDbConn.RemoveUserSession(data)
	if err != nil {
		log.Info().Msgf("data not deleted, %s", err)
	}

	data, err = mdbal.MariaDbConn.ReadUserSession("alice")
	if err == nil {
		d, _ := json.Marshal(data)
		log.Info().Msgf("found session %s", d)
	}

	mdbal.MariaDbConn.Close()
}

func createDefaultUsers() {
	log.Info().Msgf("Trying connect to database on %s", mdbal.MariaDbConn.Addr)
	mdbal.MariaDbConn.Open()

	data := model.User{Alias: "alice", ID: "0x1e66D21a5BEADC6AfeB9a74E9703EaB207Da27f2", SecretKey: "0x71b22a3a8d76707ce89966791e30994a17ab0ec078f14d251188c7e7d39a011c", PrivateKey: "0xfcfe76da28fd194ff9e206973b5059bd799a6e42129fa385276cafb8978917292cd11c0dc89292855e4bb029600faf18763f3c6cd1372fff8a4006d50a103248"}
	mdbal.MariaDbConn.CreateOrUpdateUser(data)

	data = model.User{}
	data.ID = "0x30494CB6B8e89AbE164Ddf33FB30f69150DE67cA"
	data.Alias = "bob"
	data.SecretKey = "0xccaf74bdf045db27843a990259a512fb3eb43196b14c766698c69cb677045c7a"
	data.PrivateKey = "0x3009e45ca0f53a4edaae343dc1655444e5d6ab7c5548487835b21e174c3d748c2487905fdc4bfd2c9c471808a431d1dbdea1876bf5c9018ecfd3b9909a81492f"
	mdbal.MariaDbConn.CreateOrUpdateUser(data)

	data = model.User{}
	data.ID = "0x2e248c0ce4324f9cddd0303d654dcc3eca153e12"
	data.Alias = "charlie"
	data.SecretKey = "0xf436ed6e44eee35cadb2819fee2a3174bb453a6906bc20dfd593ee52400a2b6d"
	data.PrivateKey = "0xfa5b92df9d88b1bb3aa31b88171b4ebe785ab2a83ec9d04f142d610411142cfdee54c8febb287ed4695cd1a9312f65eb9d00397a5a8216130c292f72dfc996a4"
	mdbal.MariaDbConn.CreateOrUpdateUser(data)

	data = model.User{}
	data.ID = "0x3e3e7c64e3292ae7cf5678b31121c5e706cfb91a"
	data.Alias = "dori"
	data.SecretKey = "0xc481adbbb340591611f77b8d878ae51224ac81e7f6e4a358542ef7dece853b87"
	data.PrivateKey = "0x38f5147146b77c1b874db4798a70d097d9b814ac6fd0892daf675e26b721bb6964bdaaf091ff29e95f4d3c61063eea732fa9f0a93d1adc99755cd9b0c933f565"
	mdbal.MariaDbConn.CreateOrUpdateUser(data)

	data, err := mdbal.MariaDbConn.ReadUser("alice")
	if err == nil {
		d, _ := json.Marshal(data)
		log.Info().Msgf("found user %s", d)
	}

	mdbal.MariaDbConn.Close()
}

func testSmartContracts() {
	log.Info().Msgf("Trying connect to database on %s ", mdbal.MariaDbConn.Addr)
	mdbal.MariaDbConn.Open()

	data := model.ContractsPairPaymentchannel{Name: "default", AssetHolder: "0x79DB73424A8b5BD4D65849De0d60aAE9d146A76f", Adjudicator: "0xf3f194a91eA1E77514F2e69e3B95457F89467C41"}
	mdbal.MariaDbConn.CreateOrUpdateContracts(data)

	data.Name = "test 2"
	mdbal.MariaDbConn.CreateOrUpdateContracts(data)

	data.Name = "test 3"
	mdbal.MariaDbConn.CreateOrUpdateContracts(data)

	data.Name = "test 2"
	err := mdbal.MariaDbConn.RemoveContracts(data)
	if err != nil {
		log.Info().Msgf("data not deleted, %s", err)
	}

	data, err = mdbal.MariaDbConn.ReadContracts("default")
	if err == nil {
		d, _ := json.Marshal(data)
		log.Info().Msgf("found contracts %s", d)
	}

	mdbal.MariaDbConn.Close()
}

func testSimpleDataProtocol() {
	log.Info().Msgf("Trying connect to database on %s", mdbal.MariaDbConn.Addr)
	mdbal.MariaDbConn.Open()

	jsonObj, _ := json.Marshal(model.UserSession{Alias: "my-alias", Ip_Addr: "127.0.0.1", Port: 1234})
	myJson := string(jsonObj)

	data := model.SimpleDataProtocol{
		SenderAlias:    "alice",
		ReceiverAlias:  "bob",
		MsgId:          1,
		PaymentChannel: 1,
		Data:           myJson,
	}

	mdbal.MariaDbConn.CreateSDPEntry(data)

	data = model.SimpleDataProtocol{
		SenderAlias:    "charlie",
		ReceiverAlias:  "bob",
		MsgId:          1,
		PaymentChannel: 2,
		Data:           myJson,
	}

	mdbal.MariaDbConn.CreateSDPEntry(data)
	data = model.SimpleDataProtocol{
		SenderAlias:    "alice",
		ReceiverAlias:  "bob",
		MsgId:          2,
		PaymentChannel: 1,
		Data:           myJson,
	}

	mdbal.MariaDbConn.CreateSDPEntry(data)

	entries, err := mdbal.MariaDbConn.ReadSDPEntriesBySender("alice")
	if err == nil {
		log.Info().Msgf("found %d entries ", entries.Len())
	}

	remove := entries.Back().Value.(model.SimpleDataProtocol)
	err = mdbal.MariaDbConn.RemoveSDPEntry(remove)
	if err != nil {
		log.Info().Msgf("data not deleted, %s", err)
	} else {
		d, _ := json.Marshal(remove)
		log.Info().Msgf("removed entry %s ", d)
	}

	mdbal.MariaDbConn.Close()
}

//Info does return all available accounts currently logged in
func Info(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	alias := readValueFromPath(r, "alias")
	var result model.Result
	var e model.ModelError
	var completeInfoResult model.InfoResult

	result.Indata = nil
	result.Exception = e

	config, errCfg := setAndCheckAliasConfig(alias)

	log.Info().Msg("read config")

	if errCfg != nil {
		log.Error().Msg("error read config")
		w.WriteHeader(500)
		result.Success = false
		result.Exception.ShortMessage = "cannot read config file, alias might unknown"
		result.Exception.LongMessage = errCfg.Error()
		e, _ := json.Marshal(result)
		w.Write(e)
		return
	}

	//spew.Dump(config)
	if config.Alias == "" {
		w.WriteHeader(404)
		log.Error().Msg("invalid alias")
		result.Success = false
		result.Exception.ShortMessage = "alias invalid"
		e, _ := json.Marshal(result)
		w.Write(e)
		return
	}

	log.Info().Msg("no error read config")
	node, err := newEthConnection(config)

	if err == nil {
		completeInfoResult = node.GetCurrentBalances()
	}

	// is the user already connected ?
	if sessionExists(alias) {
		sess := sessions[alias]
		irPaymentChannel, err := sess.Info(alias)
		if err == nil {
			result.Success = true
			completeInfoResult.IsConnected = true
			if irPaymentChannel.ChannelInfos != nil {
				completeInfoResult.ChannelInfos = irPaymentChannel.ChannelInfos
			}
			result.Outdata = completeInfoResult
			e, _ := json.Marshal(result)
			w.Write(e)
		} else {
			//TODO:
		}
	} else {
		completeInfoResult.IsConnected = false
		result.Success = true
		result.Exception.ShortMessage = alias + " is currently not connected."
		result.Outdata = completeInfoResult
		e, _ := json.Marshal(result)
		w.Write(e)
	}
}

//Send a balance to a user through a payment channel
func Send(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	alias := readValueFromPath(r, "alias")

	var sendMoneyAndData model.UsePaymentChannel
	var result model.Result
	var e model.ModelError

	result.Indata = sendMoneyAndData
	result.Exception = e

	errIn := json.NewDecoder(r.Body).Decode(&sendMoneyAndData)
	config, errCfg := setAndCheckAliasConfig(alias)

	if errCfg != nil {
		log.Error().Msg("error read config")
		w.WriteHeader(500)
		result.Success = false
		result.Exception.ShortMessage = errCfg.Error()
		result.Exception.Error = errCfg
		e, _ := json.Marshal(result)
		w.Write(e)
		return
	}

	if errIn != nil {
		log.Error().Msg("no body available")
		w.WriteHeader(500)
		result.Success = false
		result.Exception.ShortMessage = errIn.Error()
		result.Exception.Error = errIn
		e, _ := json.Marshal(result)
		w.Write(e)
		return
	}

	log.Info().Msg("read config")
	_ = config
	mySess := sessions[alias]
	otherSess := sessions[sendMoneyAndData.Target]

	if mySess == nil || otherSess == nil {
		log.Error().Msg("at least one session is nil, are all users connected? see info")
		w.WriteHeader(500)
		result.Success = false
		result.Exception.ShortMessage = "at least one session is nil, are all users connected? see info"
		e, _ := json.Marshal(result)
		w.Write(e)
		return
	}

	err := mySess.Backend.Send(alias, sendMoneyAndData)

	if err != nil {
		log.Printf("send money failed ... %s", err)
		w.WriteHeader(500)
		result.Success = false
		result.Exception.ShortMessage = err.Error()
		result.Exception.Error = err
		e, _ := json.Marshal(result)
		w.Write(e)
		return
	}

	w.WriteHeader(http.StatusOK)
}

//sessionExists checks if a session for an given alias is existing
func sessionExists(alias string) bool {
	var exists = true

	if sessions == nil {
		sessions = make(map[string]*pch.Session)
		exists = false
	} else {
		exists = sessions[alias] != nil
	}

	log.Info().Msgf("session exists : %t", exists)
	return exists
}
