/*
 * ODS
 *
 * This is a simple REST API to access Block Chain on Ethereum and handling Smart Contracts and Payment Channel as well.
 *
 * API version: 1.0.0
 * Contact: u.kuehn@tu-berlin.de
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package swagger

import (
	"context"
	"encoding/json"
	"math"
	"math/big"
	"net/http"
	pch "restapidemo/files/paymentchannel"
	"strconv"

	"github.com/rs/zerolog/log"

	"github.com/ethereum/go-ethereum/core/types"

	"github.com/ethereum/go-ethereum/accounts"
	"github.com/ethereum/go-ethereum/accounts/keystore"
	"github.com/ethereum/go-ethereum/crypto"
	"github.com/ethereum/go-ethereum/ethclient"
	"github.com/pkg/errors"
	pkeystore "perun.network/go-perun/backend/ethereum/wallet/keystore"

	"restapidemo/model"
)

type ethNode struct {
	wallet     *pkeystore.Wallet
	account    *pkeystore.Account
	config     *pch.Config
	ethBackend *ethclient.Client
}

//CreateUser creates a new user on eth blockchain and return with the new user object
func CreateUser(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	var newUser model.User
	var result model.Result
	var e model.ModelError

	errIn := json.NewDecoder(r.Body).Decode(&newUser)

	if errIn == nil {
		newUser.ID = "0x1234567890abcdef"
		newUser.PrivateKey = "0x424242"

		result.Success = false
		result.Indata = newUser
		result.Exception = e
		result.GasUsage = 1
		e.ShortMessage = "This is not implemnted yet. TODO: Implement this function."
	}

	b, errOut := json.Marshal(result)
	if errOut == nil {
		w.WriteHeader(200)
		w.Write(b)
	} else {
		w.WriteHeader(500)
	}
}

//DeployContract deploys an new contract
func DeployContract(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(501)
}

//EstimateDeployContractGas estimate how much gas will be used to deploy the contract
func EstimateDeployContractGas(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(501)
}

//EstimateTransactionGas estimate how much gas will be used to execute a transaction
func EstimateTransactionGas(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(501)
}

//ExecuteTransaction executes a transaction
func ExecuteTransaction(w http.ResponseWriter, r *http.Request) {
	//TODO: replace API calls with alias similar to api_paymentchannel
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	gas, errParse := strconv.ParseInt(readValueFromPath(r, "gasLimit"), 10, 64)

	var transactionData model.Transaction
	var result model.Result
	var e model.ModelError

	errIn := json.NewDecoder(r.Body).Decode(&transactionData)
	result.Indata = transactionData
	result.Exception = e

	if errParse != nil {
		w.WriteHeader(404)
		e.Error = errParse
		response, _ := json.Marshal(result)
		w.Write(response)
		return
	}

	if errIn != nil {
		w.WriteHeader(404)
		e.Error = errIn
		response, _ := json.Marshal(result)
		w.Write(response)
		return
	}

	config, err := setAndCheckAliasConfig(transactionData.Sender)
	senderNode, errSender := newEthConnection(config)

	if err != nil || errSender != nil {
		w.WriteHeader(404)
		e.Error = err
		if err == nil {
			e.Error = errSender
		}
		e.ShortMessage = "sender unknown"
		response, _ := json.Marshal(result)
		w.Write(response)
		return
	}

	config, err = setAndCheckAliasConfig(transactionData.Receiver)
	receiverNode, errReceiver := newEthConnection(config)

	if err != nil || errReceiver != nil {
		w.WriteHeader(404)
		e.Error = err
		if err == nil {
			e.Error = errReceiver
		}
		e.ShortMessage = "sender unknown"
		response, _ := json.Marshal(result)
		w.Write(response)
		return
	}

	log.Printf("sender hash %s ", senderNode.GetHashFromEthUser())
	log.Printf("receiver hash %s ", receiverNode.GetHashFromEthUser())

	senderNode.RunTranscationTo(receiverNode, transactionData.Value, gas)
}

/**
TODO: new file required ?
*/

func newEthConnection(config *pch.Config) (*ethNode, error) {
	wallet, acc, err := importAccount(config)

	if pch.OptionalConfig.BlockChainUrl != "" {
		log.Info().Msgf("Use block chain boot node %s", pch.OptionalConfig.BlockChainUrl)
		config.Chain.URL = pch.OptionalConfig.BlockChainUrl
	} else {
		log.Info().Msg("No alternative block chain boot node have been set, using local config")
	}

	if err != nil {
		log.Printf("error importing secret key in ethereum : %s", err)
		return nil, errors.WithMessage(err, "importing secret key")
	}

	eClient, err := ethclient.Dial(config.Chain.URL)
	if err != nil {
		log.Printf("error connecting to ethereum : %s", err)
		return nil, errors.WithMessage(err, "connecting to client")
	}

	return &ethNode{
		wallet:     wallet,
		account:    acc,
		config:     config.Clone(),
		ethBackend: eClient,
	}, nil
}

// importAccount is a helper method to import secret keys until we have the ethereum wallet done.
func importAccount(config *pch.Config) (*pkeystore.Wallet, *pkeystore.Account, error) {
	ks := keystore.NewKeyStore(config.WalletPath, 2, 1)
	sk, err := crypto.HexToECDSA(config.SecretKey[2:])
	if err != nil {
		log.Printf("error decoding secret : %s", err)
		return nil, nil, errors.WithMessage(err, "decoding secret key")
	}

	var ethAcc accounts.Account
	addr := crypto.PubkeyToAddress(sk.PublicKey)
	if ethAcc, err = ks.Find(accounts.Account{Address: addr}); err != nil {
		ethAcc, err = ks.ImportECDSA(sk, "")
		if err != nil && errors.Cause(err).Error() != "account already exists" {
			log.Printf("error importing secret : %s", err)
			return nil, nil, errors.WithMessage(err, "importing secret key")
		}
	}

	wallet, err := pkeystore.NewWallet(ks, "")
	if err != nil {
		log.Printf("error creating wallet : %s", err)
		return nil, nil, errors.WithMessage(err, "creating wallet")
	}

	wAcc := pkeystore.NewAccountFromEth(wallet, &ethAcc)
	acc, err := wallet.Unlock(wAcc.Address())
	return wallet, acc.(*pkeystore.Account), err
}

//GetHashFromEthUser returns user hash
func (sender *ethNode) GetHashFromEthUser() string {
	return sender.account.Account.Address.String()
}

//RunTransaction transfers amount to receiver
func (sender *ethNode) RunTranscationTo(receiver *ethNode, ethAmount int64, gasLimit int64) {
	// common addresses
	senderAddr := sender.account.Account.Address
	receiverAddr := receiver.account.Account.Address

	currentBalanceSender, errcbs := sender.ethBackend.BalanceAt(context.Background(), senderAddr, nil)
	pendingBalanceSender, errpbs := sender.ethBackend.PendingBalanceAt(context.Background(), senderAddr)
	currentBalanceReceiver, errcbr := receiver.ethBackend.BalanceAt(context.Background(), receiverAddr, nil)
	pendingBalanceReceiver, errpbr := receiver.ethBackend.PendingBalanceAt(context.Background(), receiverAddr)

	if errcbs != nil {
		log.Printf("Error occured :%s", errcbs)
	}

	if errpbs != nil {
		log.Printf("Error occured :%s", errpbs)
	}

	if errcbr != nil {
		log.Printf("Error occured :%s", errcbr)
	}

	if errpbr != nil {
		log.Printf("Error occured :%s", errpbr)
	}

	log.Printf("%s has current Eth %f with pending %f", sender.config.Alias, currentBalanceSender, pendingBalanceSender)
	log.Printf("%s has current Eth %f with pending %f", receiver.config.Alias, currentBalanceReceiver, pendingBalanceReceiver)

	gasPrice, err := sender.ethBackend.SuggestGasPrice(context.Background())

	log.Printf("suggested gas price %s in unit", gasPrice)

	nonce, err := sender.ethBackend.PendingNonceAt(context.Background(), senderAddr)

	if err != nil {
		log.Printf("error while get nonce %s", err)
	}

	chainID, err := sender.ethBackend.NetworkID(context.Background())
	if err != nil {
		log.Printf("error while get chainID %s ", err)
	}

	log.Printf("try transcation about %d ETH on chain %s with nonce %d gas limit set to %d", ethAmount, chainID, nonce, gasLimit)

	gasLimit64 := uint64(gasLimit) // in units
	amount := ConvertBalanceToWei(ethAmount)

	tx := types.NewTransaction(nonce, receiverAddr, amount, gasLimit64, gasPrice, nil)

	privSecret := sender.config.SecretKey[2:]
	privateKey, err := crypto.HexToECDSA(privSecret)

	if err != nil {
		log.Printf("get private key failed %s", err)
		return
	}

	signedTx, err := types.SignTx(tx, types.NewEIP155Signer(chainID), privateKey)

	if err != nil {
		log.Printf("signature failed %s", err)
		return
	}

	err = sender.ethBackend.SendTransaction(context.Background(), signedTx)

	if err != nil {
		log.Printf("transaction failed %s", err)
		return
	}

	// transaction done

	currentBalanceSender, errcbs = sender.ethBackend.BalanceAt(context.Background(), senderAddr, nil)
	pendingBalanceSender, errpbs = sender.ethBackend.PendingBalanceAt(context.Background(), senderAddr)
	currentBalanceReceiver, errcbr = receiver.ethBackend.BalanceAt(context.Background(), receiverAddr, nil)
	pendingBalanceReceiver, errpbr = receiver.ethBackend.PendingBalanceAt(context.Background(), receiverAddr)

	log.Printf("%s has current Eth %s with pending %s", sender.config.Alias, currentBalanceSender, pendingBalanceSender)
	log.Printf("%s has current Eth %s with pending %s", receiver.config.Alias, currentBalanceReceiver, pendingBalanceReceiver)

	sender.ethBackend.Close()
	receiver.ethBackend.Close()
}

func (sender *ethNode) GetCurrentBalances() (ir model.InfoResult) {
	// common addresses
	senderAddr := sender.account.Account.Address

	currentBalanceSender, errcbs := sender.ethBackend.BalanceAt(context.Background(), senderAddr, nil)
	pendingBalanceSender, errpbs := sender.ethBackend.PendingBalanceAt(context.Background(), senderAddr)
	count, err := sender.ethBackend.PendingTransactionCount(context.Background())

	ir.PendingTransactionCount = count

	if err == nil {
		log.Printf("currently are %d transactions pending.", count)
	}

	if errcbs != nil {
		log.Printf("Error occured :%s", errcbs)
	}

	if errpbs != nil {
		log.Printf("Error occured :%s", errpbs)
	}

	log.Printf("%s has current Eth %f with pending %f", sender.config.Alias,
		GetBalanceInEth(currentBalanceSender.String()),
		GetBalanceInEth(pendingBalanceSender.String()))

	ir.CurrentEthBalance = currentBalanceSender
	ir.CurrentEthBalanceWithPending = pendingBalanceSender

	sender.ethBackend.Close()

	return ir
}

// GetBalanceInEth tranform the eth value in from wei into eth as big.Float
func GetBalanceInEth(balInEth string) *big.Float {
	balInEthFloat := new(big.Float)
	balInEthFloat.SetString(balInEth)
	return new(big.Float).Quo(balInEthFloat, big.NewFloat(math.Pow10(18)))
}

// ConvertBalanceToWei returns the wei value for an eth value as big.Int
func ConvertBalanceToWei(balInEth int64) *big.Int {
	balInEthBig := big.NewInt(balInEth)
	pow18 := (int64)(1 * math.Pow10(18))
	return new(big.Int).Mul(balInEthBig, big.NewInt(pow18))
}
